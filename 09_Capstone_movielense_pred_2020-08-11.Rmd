---
title: "Data Science Capstone - Movielense project"
author: "Julia Schr√∂der"
date: "07/01/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(echo = FALSE,
                     warning = FALSE,
                     message = FALSE,
                     root.dir = normalizePath("/Users/julia/sciebo/Kurse/2020-03_HarvardX_DataScience/HarvardX_DS/ml-10M100K"))

library(tidyverse)
library(caret)
library(data.table)
library(lubridate)
library(RColorBrewer)
library(kableExtra)

# presets
# MovieLens 10M dataset:
# https://grouplens.org/datasets/movielens/10m/
# http://files.grouplens.org/datasets/movielens/ml-10m.zip

dl <- tempfile()
download.file("http://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)

ratings <- fread(text = gsub("::", "\t", readLines(unzip(dl, "ml-10M100K/ratings.dat"))),
                 col.names = c("userId", "movieId", "rating", "timestamp"))

movies <- str_split_fixed(readLines(unzip(dl, "ml-10M100K/movies.dat")), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")

movies <- as.data.frame(movies) %>% 
  mutate(movieId = as.numeric(movieId),
         title = as.character(title),
         genres = as.character(genres))
movielens <- left_join(ratings, movies, by = "movieId")

# # Validation set will be 10% of MovieLens data
# set.seed(1)
# # if using R 3.5 or earlier, use `set.seed(1)` instead
# test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
# edx <- movielens[-test_index,]
# temp <- movielens[test_index,]
# 
# # Make sure userId and movieId in validation set are also in edx set
# validation <- temp %>% 
#   semi_join(edx, by = "movieId") %>%
#   semi_join(edx, by = "userId")
# 
# # Add rows removed from validation set back into edx set
# removed <- anti_join(temp, validation)
# edx <- rbind(edx, removed)
# 
# rm(dl, ratings, movies, test_index, temp, movielens, removed)
# 
# fwrite(edx, "ML_edx_training_data.tsv", sep = "\t")                      
# fwrite(validation, "ML_validation_data.tsv", sep = "\t")                
# edx <- fread("ML_edx_training_data.tsv")
# validation <- fread("ML_validation_data.tsv")
```

# Introduction  
  
### Description of dataset  
The dataset used in this analysis is called "movielens" and contains 10 million ratings of movies by users. The dataset was split into the `train` (90%) and `validation` sets (10%) according to the task:  
```{r data_split, include=TRUE}
# Validation set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding")

test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]

# Make sure userId and movieId in validation set are also in edx set
validation <- temp %>%
  semi_join(edx, by = "movieId") %>%
  semi_join(edx, by = "userId")

# Add rows removed from validation set back into edx set
removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

rm(dl, ratings, movies, test_index, temp, movielens, removed)

fwrite(edx, "ML_edx_training_data.tsv", sep = "\t")
fwrite(validation, "ML_validation_data.tsv", sep = "\t")
```

The analyses going forward will only use and describe the `train` dataset. It comprises `r nrow(edx)` ratings of `r n_distinct(edx$movieId)` given by `r n_distinct(edx$userId)` users. 

### Summary of the project's goal

Goal of this project was to build a movie recommendation system. It will predict movie ratings by training a machine learning (ML) algorithm using the available ratings from the 10M version of the MovieLens dataset. Herefore, the `train` dataset was divided into a training set comprising 90% of the data and a test dataset with 10% of the data. The different features were added sequentially when building the model using the training data in order to improve the model performance, which was evaluated using the residual mean squared error.
  

# Methods

The methods applied in this project were taken from the Machine Learning course on EdX.org and the book *Introduction to Data Science"" by Prof. Rafael A. Irizarry. Data cleaning, exploratory data analysis, model selection and evaluation were performed in R using the packages from the `tidyverse`.  

At first, the data was cleaned using the `stringr` package. The release year and title of the movie was extracted from the title column. The genres were unnested by splitting the genres column by the "|" string and joining the data back using the movieId column.  

An exploratory data analysis was performed to find the key features of the dataset necessary to build the model for the recommendation system. For this, it was postulated that rating are influenced by the following effects:

1. movie
2. user
3. genre

The hypotheses were analyzed and visualized using `ggplot`.  

Next, the model was build sequentially. The basic model was simply based on the mean rating of the training dataset where every movie is predicted to have the same rating. In the next step, the effect of the rated movie was included by adding the average residual effect of the rating per movie to the model. Afterwards, the effect of the user was included by adding the average residual effect of the rating per user. Since genre also has an effect on the rating, the sum of the residual effect of the genre per movie was added, since some movies are categorized in multiple genres to the model. After each step, the residual mean squared error (RMSE) was calculated using the test dataset:
$$
RMSE = \root{\frac{1/N}\sigma{u,i}(\hat{y}_{u,i}-<_{u,i})^2}
$$
# Results  

### Data cleaning  
The movie title, year and genres were reformatted.
```{r methods_clean, include = TRUE}
title_str <- as.data.frame(str_match(edx$title, pattern =  "(.*)\\s\\((\\d{4})\\)"))

genres <- str_split(edx$genres, fixed("|"), simplify = TRUE) %>%
  as.data.frame() %>%
  bind_cols(select(edx, movieId)) %>% 
  distinct(.keep_all = TRUE) %>% 
  gather(col, genre, -movieId) %>% 
  filter(genre != "") %>% 
  select(-col)

edx_clean <- edx %>%
  mutate(movie_year = as.character(title_str[,3]),
         movie_title = as.character(title_str[,2])) %>% 
  left_join(genres, by = "movieId") %>%
  rename(movie_genre = genre) %>%
  select(userId, rating, rating_date, movieId, movie_title, movie_year, movie_genre)
```  

This is the head of the final dataframe used for further analyses:  
```{r methods_clean, echo = FALSE}
rm(title_str)
head(edx_clean, 10) %>%
  kable(format.args = list(big.mark = ",")) %>% 
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "left")
```
  
  
### Exploratory data analysis  
For the exploratory analysis, the effects of the rated movie, the user rating the movie and the genre of the rated movie were analyzed.  

These are the number of movies per rating:  
```{r intro_overview, echo = FALSE}
# show number of ratings per rating point
edx %>%
  group_by(movieId) %>%
  ggplot(aes(x = as.factor(rating), fill = as.factor(rating))) +
  geom_bar() +
  scale_y_continuous(breaks = c(0, 5e5, 1e6, 1.5e6, 2e6, 2.5e6), 
                     labels = c("0", "0.5", "1", "1.5", "2", "2.5")) +
  theme_minimal() +
  scale_fill_viridis_d(guide = FALSE) +
  labs(x = "Rating", y = "Count in millions")
```
  
These are the number of users per rating:  
```{r intro_overview, echo = FALSE}
# show number of ratings per rating point
edx %>%
  group_by(userId) %>%
  summarize(rating = mean(rating), .groups = "keep") %>%
  ggplot(aes(x = as.factor(rating), fill = as.factor(rating))) +
  geom_bar() +
  scale_y_continuous(breaks = c(0, 5e5, 1e6, 1.5e6, 2e6, 2.5e6), 
                     labels = c("0", "0.5", "1", "1.5", "2", "2.5")) +
  theme_minimal() +
  scale_fill_viridis_d(guide = FALSE) +
  labs(x = "Rating", y = "Count in millions")
```
  
These are the average ratings per genre:  
```{r intro_genre, echo = FALSE, warning=FALSE}
genres_rating <- genres %>%
  left_join(select(edx, movieId, rating), by = "movieId") %>%
  group_by(genre) %>%
  summarize(rating_avg = mean(rating, na.rm = TRUE), .groups = "keep") %>%
  arrange(desc(rating_avg))
  # head(10) %>% 
  # kable(format.args = list(big.mark = ",", digits = 3)) %>% 
  # kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE, position = "left")

ggplot(data = genres_rating, aes(x = reorder(genre, -rating_avg, sum), y = rating_avg, fill = reorder(genre, -rating_avg, sum))) +
  geom_col() +
  theme_minimal() +
  scale_fill_viridis_d(guide = FALSE) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Genres", y = "Rating average per genre")
```  

  
  
### Data setup  
The dataset was split into training and test data by splitting 10% of the dataset for testing.

```{r setup, include=TRUE}
test_index <- createDataPartition(edx_clean$rating, times=1, p=0.1, list=FALSE)
temp <- edx_clean[test_index,]
edx_train <- edx_clean[-test_index,]

# exclude users and movies that do not appear in training data
edx_test <- temp %>%
  semi_join(edx_train, by = "movieId") %>%
  semi_join(edx_train, by = "userId")

# add rows removed from test set back into training set
removed <- anti_join(temp, edx_test)
edx_train <- rbind(edx_train, removed)

rm(temp, removed)
```



### Modelling  

##### Basic model  
```{r results_mu, echo=FALSE}
mu <- mean(edx_train$rating)
rmse <- function(true_ratings, predicted_ratings){
    sqrt(mean((true_ratings - predicted_ratings)^2))
  }
rmse_mu <- rmse(edx_test$rating, mu)
rmse_all <- tibble(method = "mu_hat", RMSE = rmse_mu)
rmse_all %>%
  
```  

The most basic model for predicting the movie ratings $Y_{u,i}$ would be the average of all ratings $\hat{\mu}$ and the independent sampmling errors $\epsilon_{u,i}$:

$$
Y_{u,i}=\mu+\epsilon_{u,i}
$$

where $\hat{\mu}$ is `r mu`. The RSME is `r rmse_mu`.

##### Movie effect  
```{r results_movie, echo=FALSE, warning=FALSE}
lambdas <- seq(0,10,0.25)

rmses_movie <- sapply(lambdas, function(l){
  b_movie <- edx_train %>%
    group_by(movieId) %>%
    summarize(b_movie = sum(rating - mu)/(n()+l), .groups="keep")
  
  preds <- edx_test %>%
    left_join(b_movie, by = "movieId") %>%
    mutate(pred = mu + b_movie) %>%
    .$pred
  rmse(edx_test$rating, preds)
})

qplot(lambdas, rmses_movie)
lambdas[which.min(rmses_movie)]


rmse_all <- rbind(rmse_all, tibble(method = "+ movie effect (regularized)", RMSE = min(rmses_movie)))
```
Since certain movies are rated higher than others, the addition of a movie specific effect $b_i$ is added to the model: 

$$
Y_{u,i}=\mu+b_i+\epsilon_{u,i}
$$

The least squares estimate for this case is simply the average of the true rating $Y_{u,i}$ minus the average rating $\hat{\mu}$ per movie. This is the variation of these estimates:  
```{r results_movie_plot, echo=FALSE}
ggplot(b_movie, aes(x = b_movie, fill = b_movie)) +
  geom_histogram(bins = 10, color = "black", fill = "lightblue") + # change color!
  theme_minimal() 
```

Adding the movie effect ot the model improves the RMSE to `r rmse_movie`.  

##### User effect  
```{r results_user, echo=FALSE, warning=FALSE}
rmses_user <- sapply(lambdas, function(l){
  b_movie <- edx_train %>%
    group_by(movieId) %>%
    summarize(b_movie = sum(rating - mu)/(n()+l), .groups="keep")
  
  b_user <- edx_train %>%
    left_join(b_movie, by = "movieId") %>% 
    group_by(userId) %>%
    summarize(b_user = sum(rating - mu - b_movie)/(n()+l), .groups="keep")
  
  preds <- edx_test %>%
    left_join(b_movie, by = "movieId") %>%
    left_join(b_user, by = "userId") %>% 
    mutate(pred = mu + b_movie + b_user) %>%
    .$pred
  rmse(edx_test$rating, preds)
})

qplot(lambdas, rmses_user)
lambdas[which.min(rmses_user)]

rmse_all <- rbind(rmse_all, tibble(method = "+ user effect (regularized)", RMSE = min(rmses_user)))
```

Similarily, certain users generally rate higher or lower. We can model this as the user effect $b_u$:
$$
Y_{u,i}=\mu+b_i+b_u+\epsilon_{u,i}
$$

This effect can be estimated by computing the average of each rating $Y_{u,i}$ minus the average rating $\hat{\mu}$ and minus the movie effect $b_i$ per user. This improves the RMSE further to `r rmse_user`.

##### Genre effect  
sum of genre effects of all genres of the respective movie
```{r results_genre, echo=FALSE, warning=FALSE}
rmses_genre <- sapply(lambdas, function(l){
  b_movie <- edx_train %>%
    group_by(movieId) %>%
    summarize(b_movie = sum(rating - mu)/(n()+l), .groups="keep")
  
  b_user <- edx_train %>%
    left_join(b_movie, by = "movieId") %>% 
    group_by(userId) %>%
    summarize(b_user = sum(rating - mu - b_movie)/(n()+l), .groups="keep")
  
  b_genre <- edx_train %>%
    left_join(b_movie, by = "movieId") %>% 
    left_join(b_user, by = "userId") %>% 
    group_by(movie_genre) %>%
    summarize(b_genre = sum(rating - mu - b_movie - b_user)/(n()+l), .groups="keep")
  
  preds <- edx_test %>%
    left_join(b_movie, by = "movieId") %>%
    left_join(b_user, by = "userId") %>% 
    left_join(b_genre, by = "movie_genre") %>% 
    group_by(movieId, userId) %>%
    mutate(pred = mu + b_movie + b_user + sum(b_genre)) %>%
    .$pred
  rmse(edx_test$rating, preds)
})

qplot(lambdas, rmses_genre)
lambdas[which.min(rmses_genre)]

rmse_all <- rbind(rmse_all, tibble(method = "+ genre effect (regularized)", RMSE = min(rmses_genre)))
```

<!-- ##### Year of movie release effect   -->
<!-- ```{r results_year, echo=FALSE, warning=FALSE} -->
<!-- rmses_year <- sapply(lambdas, function(l){ -->
<!--   b_movie <- edx_train %>% -->
<!--     group_by(movieId) %>% -->
<!--     summarize(b_movie = sum(rating - mu)/(n()+l), .groups="keep") -->

<!--   b_user <- edx_train %>% -->
<!--     left_join(b_movie, by = "movieId") %>%  -->
<!--     group_by(userId) %>% -->
<!--     summarize(b_user = sum(rating - mu - b_movie)/(n()+l), .groups="keep") -->

<!--   b_genre <- edx_train %>% -->
<!--     left_join(b_movie, by = "movieId") %>%  -->
<!--     left_join(b_user, by = "userId") %>%  -->
<!--     group_by(movie_genre) %>% -->
<!--     summarize(b_genre = sum(rating - mu - b_movie - b_user)/(n()+l), .groups="keep") -->

<!--   b_year <- edx_train %>% -->
<!--     left_join(b_movie, by = "movieId") %>%  -->
<!--     left_join(b_user, by = "userId") %>%  -->
<!--     left_join(b_genre, by = "movie_genre") %>%  -->
<!--     group_by(movie_year) %>% -->
<!--     summarize(b_year = sum(rating - mu - b_movie - b_user - b_genre)/(n()+l), .groups="keep") -->

<!--   preds <- edx_test %>% -->
<!--     left_join(b_movie, by = "movieId") %>% -->
<!--     left_join(b_user, by = "userId") %>%  -->
<!--     left_join(b_genre, by = "movie_genre") %>%  -->
<!--     left_join(b_year, by = "movie_year") %>%  -->
<!--     group_by(movieId, userId) %>% -->
<!--     mutate(pred = mu + b_movie + b_user + sum(b_genre) + b_year) %>% -->
<!--     .$pred -->
<!--   rmse(edx_test$rating, preds) -->
<!-- }) -->

<!-- qplot(lambdas, rmses_year) -->
<!-- lambdas[which.min(rmses_year)] -->

<!-- rmse_all <- rbind(rmse_all, tibble(method = "+ year (regularized)", RMSE = min(rmses_year))) -->
<!-- ``` -->

# Conclusion
 RMSE < 0.86490
### Brief summary of report  

### Limitations  

### Future work  